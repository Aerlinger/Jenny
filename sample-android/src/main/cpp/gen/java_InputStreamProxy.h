/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues.
 */
#pragma once

#include <jni.h>
#include <assert.h>                        
#include <atomic>
#include <mutex>

namespace java {
class InputStreamProxy {

public:
    static constexpr auto FULL_CLASS_NAME = "java/io/InputStream";



private:

    JNIEnv* mJniEnv;
    jobject mJavaObjectReference;

public:

    static bool initClazz(JNIEnv* env);
    
    static void releaseClazz(JNIEnv* env);

    static void assertInited(JNIEnv* env) {
        auto initClazzSuccess = initClazz(env);
        assert(initClazzSuccess);
    }

    InputStreamProxy(): InputStreamProxy(nullptr, nullptr) {}
    
    InputStreamProxy(JNIEnv* env, jobject javaObj)
            : mJniEnv(env), mJavaObjectReference(javaObj) {
        if (env) { assertInited(env); }
    }

    InputStreamProxy(const InputStreamProxy& from) = default;
    InputStreamProxy &operator=(const InputStreamProxy &) = default;

    InputStreamProxy(InputStreamProxy&& from) noexcept
           : mJniEnv(from.mJniEnv), mJavaObjectReference(from.mJavaObjectReference) {
        from.mJavaObjectReference = nullptr;
    }
    
    InputStreamProxy& operator=(InputStreamProxy&& from) noexcept {
       mJniEnv = from.mJniEnv;
       std::swap(mJavaObjectReference, from.mJavaObjectReference);
       return *this;
   }

    ~InputStreamProxy() = default;
    
    // helper method to get underlay jobject reference
    jobject operator*() const {
       return mJavaObjectReference;
    }
    
    // helper method to check underlay jobject reference is not nullptr
    operator bool() const {
       return mJavaObjectReference;
    }
    
    // helper method to delete JNI local ref.
    // use only when you really understand JNIEnv::DeleteLocalRef.
    void deleteLocalRef() {
       if (mJavaObjectReference) {
           mJniEnv->DeleteLocalRef(mJavaObjectReference);
           mJavaObjectReference = nullptr;
       }
    }
    
    // === java methods below ===
    
    // construct: public InputStream()
    static InputStreamProxy newInstance(JNIEnv* env) noexcept {
       assertInited(env);
       return InputStreamProxy(env, env->NewObject(getClassInitState().sClazz, getClassInitState().sConstruct_0));
    } 
    

    // method: public abstract int read()
    jint read() const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, getClassInitState().sMethod_read_0);
    }

    // method: public int read(byte[] b)
    jint read(jbyteArray b) const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, getClassInitState().sMethod_read_1, b);
    }

    // method: public int read(byte[] b, int off, int len)
    jint read(jbyteArray b, jint off, jint len) const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, getClassInitState().sMethod_read_2, b, off, len);
    }

    // method: public long skip(long n)
    jlong skip(jlong n) const {
        return mJniEnv->CallLongMethod(mJavaObjectReference, getClassInitState().sMethod_skip_0, n);
    }

    // method: public int available()
    jint available() const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, getClassInitState().sMethod_available_0);
    }

    // method: public void close()
    void close() const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, getClassInitState().sMethod_close_0);
    }

    // method: public synchronized void mark(int readlimit)
    void mark(jint readlimit) const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, getClassInitState().sMethod_mark_0, readlimit);
    }

    // method: public synchronized void reset()
    void reset() const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, getClassInitState().sMethod_reset_0);
    }

    // method: public boolean markSupported()
    jboolean markSupported() const {
        return mJniEnv->CallBooleanMethod(mJavaObjectReference, getClassInitState().sMethod_markSupported_0);
    }



private:
    struct ClassInitState {
    // thread safe init
    std::atomic_bool sInited {};
    std::mutex sInitLock {};

    jclass sClazz = nullptr;
    jmethodID sConstruct_0 = nullptr;

    jmethodID sMethod_read_0 = nullptr;
    jmethodID sMethod_read_1 = nullptr;
    jmethodID sMethod_read_2 = nullptr;
    jmethodID sMethod_skip_0 = nullptr;
    jmethodID sMethod_available_0 = nullptr;
    jmethodID sMethod_close_0 = nullptr;
    jmethodID sMethod_mark_0 = nullptr;
    jmethodID sMethod_reset_0 = nullptr;
    jmethodID sMethod_markSupported_0 = nullptr;


   }; // endof struct ClassInitState

   template <typename T = void>
   static ClassInitState& getClassInitState() {
       static ClassInitState classInitState;
       return classInitState;
   }

};
} // endof namespace java




// external logger function passed by jenny.errorLoggerFunction
void jennySampleErrorLog(JNIEnv* env, const char* error);

namespace java {

/*static*/ inline bool InputStreamProxy::initClazz(JNIEnv* env) {
#define JENNY_CHECK_NULL(val)                      \
       do {                                        \
           if ((val) == nullptr) {                 \
               jennySampleErrorLog(env, "can't init InputStreamProxy::" #val); \
               return false;                       \
           }                                       \
       } while(false)

    auto& state = getClassInitState();
    if (!state.sInited) {
        std::lock_guard<std::mutex> lg(state.sInitLock);
        if (!state.sInited) {
            auto clazz = env->FindClass(FULL_CLASS_NAME);
            JENNY_CHECK_NULL(clazz);
            state.sClazz = reinterpret_cast<jclass>(env->NewGlobalRef(clazz));
            env->DeleteLocalRef(clazz);
            JENNY_CHECK_NULL(state.sClazz);

            state.sConstruct_0 = env->GetMethodID(state.sClazz, "<init>", "()V");
            JENNY_CHECK_NULL(state.sConstruct_0);


            state.sMethod_read_0 = env->GetMethodID(state.sClazz, "read", "()I");
            JENNY_CHECK_NULL(state.sMethod_read_0);

            state.sMethod_read_1 = env->GetMethodID(state.sClazz, "read", "([B)I");
            JENNY_CHECK_NULL(state.sMethod_read_1);

            state.sMethod_read_2 = env->GetMethodID(state.sClazz, "read", "([BII)I");
            JENNY_CHECK_NULL(state.sMethod_read_2);

            state.sMethod_skip_0 = env->GetMethodID(state.sClazz, "skip", "(J)J");
            JENNY_CHECK_NULL(state.sMethod_skip_0);

            state.sMethod_available_0 = env->GetMethodID(state.sClazz, "available", "()I");
            JENNY_CHECK_NULL(state.sMethod_available_0);

            state.sMethod_close_0 = env->GetMethodID(state.sClazz, "close", "()V");
            JENNY_CHECK_NULL(state.sMethod_close_0);

            state.sMethod_mark_0 = env->GetMethodID(state.sClazz, "mark", "(I)V");
            JENNY_CHECK_NULL(state.sMethod_mark_0);

            state.sMethod_reset_0 = env->GetMethodID(state.sClazz, "reset", "()V");
            JENNY_CHECK_NULL(state.sMethod_reset_0);

            state.sMethod_markSupported_0 = env->GetMethodID(state.sClazz, "markSupported", "()Z");
            JENNY_CHECK_NULL(state.sMethod_markSupported_0);



            state.sInited = true;
        }
    }
#undef JENNY_CHECK_NULL
   return true;
}

/*static*/ inline void InputStreamProxy::releaseClazz(JNIEnv* env) {
    auto& state = getClassInitState();
    if (state.sInited) {
        std::lock_guard<std::mutex> lg(state.sInitLock);
        if (state.sInited) {
            env->DeleteGlobalRef(state.sClazz);
            state.sClazz = nullptr;
            state.sInited = false;
        }
    }
}


} // endof namespace java
