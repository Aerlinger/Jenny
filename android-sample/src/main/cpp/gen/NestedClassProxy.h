/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues,
 * or contact author landerlyoung@gmail.com.
 */
#pragma once

#include <jni.h>
#include <assert.h>                        
#include <atomic>
#include <mutex>

class NestedClassProxy {

public:
    static constexpr auto FULL_CLASS_NAME = "io/github/landerlyoung/jennysampleapp/Callback$NestedClass";
    
private:
    static jclass sClazz;

    static jmethodID sConstruct_0;

    static jmethodID sMethod_hello_0;


private:
    static std::atomic_bool sInited;
    static std::mutex sInitLock;

private:
    JNIEnv* mJniEnv;
    jobject mJavaObjectReference;

public:

    static bool initClazz(JNIEnv *env);
    
    static void releaseClazz(JNIEnv *env);

    static void assertInited(JNIEnv *env) {
        assert(initClazz(env));
    }

    NestedClassProxy(JNIEnv *env, jobject javaObj)
            : mJniEnv(env), mJavaObjectReference(javaObj) {
        assertInited(env);
    }

    NestedClassProxy(const NestedClassProxy &from) = default;
    NestedClassProxy &operator=(const NestedClassProxy &) = default;

    // trivial struct, no move needed
    NestedClassProxy(const NestedClassProxy &&from) = delete;

    ~NestedClassProxy() = default;
    
    // construct: public NestedClass()
    static jobject newInstance(JNIEnv* env, jobject enclosingClass) noexcept {
       assertInited(env);
       return env->NewObject(sClazz, sConstruct_0, enclosingClass);
    } 
    

    // method: public void hello()
    void hello(jobject enclosingClass) const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, sMethod_hello_0, enclosingClass);
    }


};