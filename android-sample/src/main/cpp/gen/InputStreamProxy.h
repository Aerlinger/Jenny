/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE WITHOUT COPYING TO YOUR SRC DIRECTORY.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues,
 * or contact author landerlyoung@gmail.com.
 */
#pragma once

#include <jni.h>
#include <assert.h>                        
#include <atomic>
#include <mutex>

class InputStreamProxy {

public:
    static constexpr auto FULL_CLASS_NAME = "java/io/InputStream";
    
private:
    static jclass sClazz;

    static jmethodID sConstruct_0;

    static jmethodID sMethod_read_0;
    static jmethodID sMethod_read_1;
    static jmethodID sMethod_read_2;
    static jmethodID sMethod_markSupported_3;
    static jmethodID sMethod_available_4;
    static jmethodID sMethod_skip_5;
    static jmethodID sMethod_reset_6;
    static jmethodID sMethod_close_7;
    static jmethodID sMethod_mark_8;


private:
    static std::atomic_bool sInited;
    static std::mutex sInitLock;

private:
    JNIEnv* mJniEnv;
    jobject mJavaObjectReference;

public:

    static bool initClazz(JNIEnv *env);
    
    static void releaseClazz(JNIEnv *env);

    static void assertInited(JNIEnv *env) {
        assert(initClazz(env));
    }

    InputStreamProxy(JNIEnv *env, jobject javaObj)
            : mJniEnv(env), mJavaObjectReference(javaObj) {
        assertInited(env);
    }

    InputStreamProxy(const InputStreamProxy &from) = default;
    InputStreamProxy &operator=(const InputStreamProxy &) = default;

    // trivial struct, no move needed
    InputStreamProxy(const InputStreamProxy &&from) = delete;

    ~InputStreamProxy() = default;
    
    // construct InputStream()
    jobject newInstance() noexcept {
       assertInited(mJniEnv);
       return mJniEnv->NewObject(sClazz, sConstruct_0);
    } 
    

    // method: int read()
    jint read() const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, sMethod_read_0);
    }

    // method: int read(byte[] b)
    jint read(jbyteArray b) const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, sMethod_read_1, b);
    }

    // method: int read(byte[] b, int off, int len)
    jint read(jbyteArray b,jint off,jint len) const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, sMethod_read_2, b, off, len);
    }

    // method: boolean markSupported()
    jboolean markSupported() const {
        return mJniEnv->CallBooleanMethod(mJavaObjectReference, sMethod_markSupported_3);
    }

    // method: int available()
    jint available() const {
        return mJniEnv->CallIntMethod(mJavaObjectReference, sMethod_available_4);
    }

    // method: long skip(long n)
    jlong skip(jlong n) const {
        return mJniEnv->CallLongMethod(mJavaObjectReference, sMethod_skip_5, n);
    }

    // method: void reset()
    void reset() const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, sMethod_reset_6);
    }

    // method: void close()
    void close() const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, sMethod_close_7);
    }

    // method: void mark(int readlimit)
    void mark(jint readlimit) const {
        mJniEnv->CallVoidMethod(mJavaObjectReference, sMethod_mark_8, readlimit);
    }


};