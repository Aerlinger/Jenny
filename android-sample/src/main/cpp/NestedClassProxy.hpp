/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE WITHOUT COPYING TO YOUR SRC DIRECTORY.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues,
 * or contact author landerlyoung@gmail.com.
 */
#pragma once

#include <jni.h>
#include <assert.h>

#ifdef __EXCEPTIONS
#include <stdexcept>
#endif

#define CHECK_NULL(val) do {if ((val) == nullptr) return false;} while(false)

class NestedClassProxy {
public:
    static constexpr const char *const FULL_CLASS_NAME = "com/young/jennysampleapp/Callback$NestedClass";


private:
    static jclass sClazz;

    static jmethodID sConstruct_0;

    static jmethodID sMethod_hello_0;


    const bool mGlobal;
    jobject mJavaObjectReference;

public:
    static bool init_clazz(JNIEnv *env) {
        if (sClazz == nullptr) {
            auto localClazz = env->FindClass(FULL_CLASS_NAME);
            CHECK_NULL(localClazz);
            sClazz = reinterpret_cast<jclass>(env->NewGlobalRef(localClazz));
            CHECK_NULL(sClazz);

            sConstruct_0 = env->GetMethodID(sClazz, "<init>", "(Lcom/young/jennysampleapp/Callback;)V");
            CHECK_NULL(sConstruct_0);

            sMethod_hello_0 = env->GetMethodID(sClazz, "hello", "()V");
            CHECK_NULL(sMethod_hello_0);


            return true;
        }
        return true;
    }

    static void release_clazz(JNIEnv *env) {
        if (sClazz != nullptr) {
            env->DeleteGlobalRef(sClazz);
            sClazz = nullptr;
        }
    }

    //construct
    static jobject newInstance(JNIEnv *env, jobject enclosingClass) noexcept {
        if (init_clazz(env)) {
            return env->NewObject(sClazz, sConstruct_0, enclosingClass);
        }
        return nullptr;
    }



    ///throw std::runtime_error when construct GlobalRef failed
    NestedClassProxy(JNIEnv *env, jobject javaObj, bool global)
#ifdef __EXCEPTIONS
    throw(std::runtime_error)
#endif
            : mGlobal(global) {
        if (init_clazz(env)) {
            mJavaObjectReference = global ? env->NewGlobalRef(javaObj) : javaObj;
        }
#ifdef __EXCEPTIONS
        if (mGlobal && mJavaObjectReference == nullptr) {
            throw std::runtime_error("cannot create global reference");
        }
#endif
    }

    bool isGlobalReferencePresent() {
        return mJavaObjectReference != nullptr;
    }

    ///no copy construct
    NestedClassProxy(const NestedClassProxy &from) = delete;

    void deleteGlobalReference(JNIEnv *env) {
        if (mGlobal) {
            env->DeleteGlobalRef(mJavaObjectReference);
            mJavaObjectReference = nullptr;
        }
    }

    ~NestedClassProxy() {
        assert(!mGlobal || mJavaObjectReference == nullptr);
    }

    void hello(JNIEnv *env, jobject enclosingClass) const {
        env->CallVoidMethod(mJavaObjectReference, sMethod_hello_0, enclosingClass);
    }





};

//static fields
jclass NestedClassProxy::sClazz = nullptr;
jmethodID NestedClassProxy::sConstruct_0 = nullptr;
jmethodID NestedClassProxy::sMethod_hello_0 = nullptr;


#undef CHECK_NULL
